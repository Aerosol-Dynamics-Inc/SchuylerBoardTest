/*
 * spi_FLASH.c
 *
 * Created: 7/12/2023 2:36:56 PM
 *  Author: greg
 */ 
#include <avr/io.h>
#define TESTFLASH 0
  
#if TESTFLASH/******************************************* * * test code used during board debugging * *******************************************/uint8_t spiTestFLASH(uint32_t address){//	uint8_t ret,i;	uint8_t mosi[10],miso[10];	for ( uint8_t i=0;i<10; i++)	{		mosi[i] = i*(i+1);		printf("%d ", mosi[i]);	}	//	if (!spi_FlashEnableWrite())//		printf("enable failed");	spi_Flash_Write( address, mosi,  10);	printf("\ndone writing test\n");		spi_Flash_Read(address, miso,10);	for ( uint8_t i=0;i<10; i++)	{		printf("%d %d\n", i, miso[i]);	}	printf("\ndone reading test\n");	return 0;					//	return 0;}/********************************************************************* *  check write in progress bit (WIP) in status register to see if chip is writing. *  returns zero if not writing, and 1 (i.e.) _BV(FLASH_WIP_BIT) if writing.**********************************************************************/uint8_t spi_FlashIsWriting(void)   {	uint8_t ret;		spi_chipSelect(CSFLASH);	spiTransferByte(FLASH_READ_STATUS_REGISTER);    // send command	ret = spiTransferByte(0) & _BV(FLASH_WIP_BIT);  // check response	spi_chipDeSelect(CSFLASH);	return ret;}/********************************************************************* *   *  uint8_t spi_FlashEnableWrite(void) *      send write enable command, then read status register *      Return 1 if write in progress bit (WIP) is not set  *               and write enabled bit (WEL) is set *      Return zero if WIP = 1 or WEL = 0; ***********************************************************************/uint8_t spi_FlashEnableWrite(void)   {	spi_chipSelect(CSFLASH);	spiTransferByte(FLASH_WRITE_ENABLE);         	spi_chipDeSelect(CSFLASH);	spi_chipSelect(CSFLASH);                     	// check if we successful	spiTransferByte(FLASH_READ_STATUS_REGISTER);	uint8_t statReg = spiTransferByte(0);	spi_chipDeSelect(CSFLASH);			// write enabled (WEL=0) and write not in progress (WIP =0)	return    (statReg & (_BV(FLASH_WEL_BIT)  | _BV(FLASH_WIP_BIT) ) ) == _BV(FLASH_WEL_BIT)   ? 1 : 0  ;  }uint8_t spi_FlashEraseChip(void)   {	if (!spi_FlashEnableWrite())	{		return RETURN_ERROR;	}	spi_chipSelect(CSFLASH);	spiTransferByte(FLASH_CHIP_ERASE);	spi_chipDeSelect(CSFLASH);	return RETURN_OK;}/*************************************  Write numBytes to Flash*************************************/uint8_t spi_Flash_Write(uint32_t address, uint8_t *mosi,  uint8_t numBytes){	// check if write in progress (WIP),	if (spi_FlashIsWriting())   // 	{		printf("\nERROR: FLASH still writing\n");		//  TRYAGAIN with TIMEOUT  		return 0;	}	if (!spi_FlashEnableWrite())	{		printf("\nERROR: FLASH write not ready\n");		return 0;	}					spi_chipSelect(CSFLASH);	//Set Program mode	spiTransferByte(FLASH_PROGRAM_PAGE_4BYTE);	spiSendFlashAddr(address);      //	spiSendBytes(addr, 4);	// write Data	if ( ((uint16_t)numBytes + (uint8_t)(address & 0xFF)) > 256 )   // writing across page, assume error so  don't write	{		printf("ERROR: overwriting page boundary. Not writing");		// throw error		return 0;	}	spiSendBytes(mosi, numBytes);	spi_chipDeSelect(CSFLASH);	return numBytes;}/*************************************  Read numBytes from Flash*************************************/uint8_t spi_Flash_Read(uint32_t address, uint8_t *miso,  uint8_t numBytes){	uint8_t statReg;		// check if write in progress (WIP), wait until done.	statReg = 0;	while (statReg & _BV(FLASH_WIP_BIT))	{		spi_chipSelect(CSFLASH);		spiTransferByte(FLASH_READ_STATUS_REGISTER);		statReg =spiTransferByte(0);		spi_chipDeSelect(CSFLASH);	}		spi_chipSelect(CSFLASH);	spiTransferByte(FLASH_4BYTE_READ); // set read mode	spiSendFlashAddr(address);      	spiGetBytes(miso, numBytes);	spi_chipDeSelect(CSFLASH);	return numBytes;}#endif