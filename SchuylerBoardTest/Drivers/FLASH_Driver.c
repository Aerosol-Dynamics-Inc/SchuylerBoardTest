/*
 * FLASH_Driver.c
 *
 * Created: 7/13/2023 5:02:42 PM
 *  Author: greg
 */ 

#include <avr/io.h>#include <stdio.h>#include "EnablesAndCSs.h"#include "Globals.h"#include "spi.h"//					              BYTES: Address, Dummy, Data					#define FLASH_RESET 0xFF            //   0,0,0#define FLASH_GET_FEATURES 0x0F     //   1,0,1#define FLASH_SET_FEATURES 0x1F     //   1,0,1 #define FLASH_READ_ID      0x9F     //   0,1,2 #define FLASH_PAGE_READ    0x13     //   3,0,0  Array read#define FLASH_READ_PAGE_CACHE_RANDOM    0x30  // 3,0,0, byte read#define FLASH_READ_PAGE_CACHE_LAST      0x3F  // 0,0,0, byte read#define FLASH_READ_FROM_CACHEx1			0x03// or 0x0B  2,1, 1-2176#define FLASH_READ_FROM_CACHEx2			0x3B//2,1, 1-2176#define FLASH_READ_FROM_CACHEx4			0x6B//2,1, 1-2176#define FLASH_READ_FROM_CACHE_DUAL_IO	0xBB//2,1, 1-2176#define FLASH_READ_FROM_CACHE_QUAD_IO	0xEB//2,2, 1-2176#define FLASH_WRITE_ENABLE              0x06// 0,0,0
#define FLASH_WRITE_DISABLE             0x04// 0,0,0
#define FLASH_BLOCK_ERASE               0xD8// 3,0,0
#define FLASH_PROGRAM_EXECUTE           0x10// 3,0,0   Array program
#define FLASH_LOADx1                    0x02// 2,0,1-2176
#define FLASH_LOADx4                    0x32// 2,0,1-2176  CAN'T USE
#define FLASH_LOAD_RANDOM_DATAx1        0x84// 2,0,1-2176
#define FLASH_LOAD_RANDOM_DATAx4        0x34// 2,0,1-2176   CAN'T USE
#define FLASH_PERMANENT_BLOCK_LOCK_PROTECTION 0x2C//3,0,0 


//#define FLASH_WEL_BIT 1   // write enable bit in status register
//#define FLASH_WIP_BIT 0   // write in progress bit in status register
//Read Flash ID:  0 address, 1 dummy, 2 Datavoid spi_FlashReadID(void)     {	uint8_t miso[2];		selectFlash();	spiTransferByte(FLASH_READ_ID);	spiTransferByte(0);	miso[1] = spiTransferByte(0);	miso[2] = spiTransferByte(0);	deSelectFlash();	printf("\n0x%02x, 0x%02x\n", miso[1],miso[2]);	}/********************************************************************* *  check write in progress bit (WIP) in status register to see if chip is writing. *  returns zero if not writing, and 1 (i.e.) _BV(FLASH_WIP_BIT) if writing.**********************************************************************//*uint8_t spi_FlashIsWriting(void)   {	uint8_t ret;		selectFlash();	spiTransferByte(FLASH_READ_STATUS_REGISTER);    // send command	ret = spiTransferByte(0) & _BV(FLASH_WIP_BIT);  // check response	deSelectFlash();	return ret;}*//*uint8_t getFlashStatusReister(void){	selectFlash();	// check if we successful	spiTransferByte(FLASH_READ_STATUS_REGISTER);	uint8_t statReg = spiTransferByte(0);	deSelectFlash();	printf("\n0x%2X\n", statReg);	return statReg;}void spi_FlashDisableWrite(void){	selectFlash();	spiTransferByte(FLASH_WRITE_DISABLE);	deSelectFlash();	selectFlash();	// check if we successful	spiTransferByte(FLASH_READ_STATUS_REGISTER);	uint8_t statReg = spiTransferByte(0);	printf("\n0x%2X\n", statReg);	deSelectFlash();}*//********************************************************************* *   *  uint8_t spi_FlashEnableWrite(void) *      send write enable command, then read status register *      Return 1 if write in progress bit (WIP) is not set  *               and write enabled bit (WEL) is set *      Return zero if WIP = 1 or WEL = 0; ***********************************************************************//*uint8_t spi_FlashEnableWrite(void)   {	selectFlash();	spiTransferByte(FLASH_WRITE_ENABLE);         	deSelectFlash();	selectFlash();                     	// check if we successful	spiTransferByte(FLASH_READ_STATUS_REGISTER);	uint8_t statReg = spiTransferByte(0);	deSelectFlash();	printf("\n0x%2X\n", statReg);			// write enabled (WEL=0) and write not in progress (WIP =0)	return    (statReg & (_BV(FLASH_WEL_BIT)  | _BV(FLASH_WIP_BIT) ) ) == _BV(FLASH_WEL_BIT)   ? 1 : 0  ;  }uint8_t spi_FlashEraseChip(void)  {	if (!spi_FlashEnableWrite())	{		return RETURN_ERROR;	}	selectFlash();	spiTransferByte(FLASH_CHIP_ERASE);	deSelectFlash();	return RETURN_OK;}*//*************************************  Write numBytes to Flash*************************************//*uint8_t spi_Flash_Write(uint32_t address, uint8_t *mosi,  uint8_t numBytes){	// check if write in progress (WIP),	if (spi_FlashIsWriting())   // 	{		printf("\nERROR: FLASH still writing\n");		//  TRYAGAIN with TIMEOUT  		return 0;	}	if (!spi_FlashEnableWrite())	{		printf("\nERROR: FLASH write not ready\n");		return 0;	}					selectFlash();	//Set Program mode	spiTransferByte(FLASH_PROGRAM_PAGE_4BYTE);	spiSend4ByteBigEndian(address);      //	spiSendBytes(addr, 4);	// write Data	if ( ((uint16_t)numBytes + (uint8_t)(address & 0xFF)) > 256 )   // writing across page, assume error so  don't write	{		printf("ERROR: overwriting page boundary. Not writing");		// throw error		return 0;	}	spiSendBytes(mosi, numBytes);	deSelectFlash();	return numBytes;}*//*************************************  Read numBytes from Flash*************************************//*uint8_t spi_Flash_Read(uint32_t address, uint8_t *miso,  uint8_t numBytes){	uint8_t statReg;		// check if write in progress (WIP), wait until done.	statReg = 0;	while (statReg & _BV(FLASH_WIP_BIT))	{		selectFlash();		spiTransferByte(FLASH_READ_STATUS_REGISTER);		statReg =spiTransferByte(0);		deSelectFlash();	}		selectFlash();	spiTransferByte(FLASH_4BYTE_READ); // set read mode	spiSend4ByteBigEndian(address);      	spiGetBytes(miso, numBytes);	deSelectFlash();	return numBytes;}*/